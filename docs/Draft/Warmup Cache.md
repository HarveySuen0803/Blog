### 缓存预热服务介绍

随着业务的发展，系统的访问量和数据量不断增加，导致服务响应时间变长，用户体验下降。通过缓存预热，可以每天提前将热点数据加载到缓存中，这样就不需要再去查询底表，不需要再去进行复杂的计算和逻辑处理，即可大大提高查询性能。

缓存预热 由 缓存 和 预热 两个动作组成：

- 缓存：接口将本次请求查询到的数据保存到缓存中，后续同样的查询只需要查询缓存，不需要再去查询底表，不需要再去进行复杂的计算和逻辑处理，即可大大提高查询性能。
- 预热：既然接口支持了缓存的能力，那么我们只需要由系统去调用一下该接口，让这个接口提前把高热数据缓存起来，即可提高首屏访问速度。

### 缓存预热方案对比

传统缓存预热方案就是针对每个接口做专门的预热，收集一些热点数据，通过定时任务每天定时跑一遍，或者干脆是在项目启动时，自动加载一些热点数据，这种方案存在诸多缺点，导致预热效果非常不理想：

- 不够通用：这种方案是针对单一接口的，不够通用，想要预热其他的接口就需要再去额外针对性的预热，太低效，耗费的人力太多。
- 不够全面：这里统计的热点数据往往体量都比较少，样本量不够全面，只能覆盖一些常用的请求。
- 不够变通：如果请求参数里携带了日期类型等需要不断变化的参数，传统的预热方案就很难应付了。

我提供的通用缓存预热方案，着重就在于解决上面几个问题，系统会自动收集各个服务的日志，进行过滤和分类。每天会去主动分析日志，推测用户行为，生成缓存预热任务去模拟用户请求，最终希望提升首屏响应率，TP90，TP95 等指标。

- 足够通用：一套缓存预热方案，可以作用于所有的接口。
- 足够全面：自动收集过往的日志，样本量足够全面，可以站在不同的维度分析日志，推测用户行为。
- 足够变通：构建了一套诊断决策树，可以搞定定制化日志分析的策略，更精细化控制分析的流程和步骤。

### 缓存预热服务架构图

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031223401.png)

架构上，参考了定时调度系统，设计了 调度中心 Monitor Service 和 调度节点 Service A，Service B。

Service A 和 Service B 是服务接入方，只需要导入相应的 SDK 后，做一些简单配置，即可完成接入，SDK 包中包含一个内嵌的 Web 服务器，我们称为任务执行器，用于和 Monitor Service 进行 RPC 通信，执行缓存预热任务。业务方接入缓存预热后，可以在我们的服务治理平台指定哪些接口需要进行缓存预热，开启缓存预热后，Monitor Service 会去自动收集 Service A  和 Service B 的日志。

Monitor Service 是服务提供方，负责管理日志，管理预热任务，也是整个系统的调度中心，负责派发预热任务到指定的服务上执行。

### 日志收集

业务方接入缓存预热后，在访问指定接口后，会将请求日志记录到指定的文件中，参考目前成熟的的 Kafka 日志同步方案，同步到 Monitor Service 的日志表中，用于后续日志分析。

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031250201.png)

### 日志分析

我们会去构建一套诊断决策树，用于日志分析。诊断决策树的执行流程是，在满足某个 条件 Condition 后，执行某个 行为 Action，类似于编程中的 if-else。一个 条件 Condition 或 一个 行为 Action 就是一个 算子 Operation，我们的会去提供大量的 Operation 用于构建这套诊断决策树。业务方需要利用这些算子来构建自己想要的分析策略。

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031229772.png)

这里举一个简单例子，要在门组 dateType 为 day 的情况下，去修改 beginDate 和 endDate 的日期：

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031229652.png)

```json
[
  // 默认策略，什么也不改变
  {
    "type": "default"
  },
  // json_path_date 策略，通过 json_path 来调整日期
  {
    "type": "json_path_date",
    "desc": "offset day of beginDate param",
    // 策略行为
    "actions": [
      // 通过 $[1][0].beginDate 定位到 beginDate 属性，将日期向后偏移一天
      {
        "type": "json_path_date",
        "path": "$[1][0].beginDate",
        "formatter": "yyyy-MM-dd",
        "operator": "offset_day",
        "value": "1"
      },
      // 通过 $[1][0].endDate 定位到 endDate 属性，将日期向后偏移一天
      {
        "type": "json_path_date",
        "path": "$[1][0].endDate",
        "formatter": "yyyy-MM-dd",
        "operator": "offset_day",
        "value": "1"
      }
    ],
    // 策略条件，满足该条件后，就会去执行上面的行为
    "conditions": [
      // 通过 $[1][0].dateType 匹配到 dateType 属性，当 dateType 属性值为 day 时，就认为满足了条件
      {
        "type": "json_path_value",
        "path": "$[1][0].dateType",
        "operator": "eq",
        "value": "day"
      }
    ]
  }
]
```

### 组件配置

接口可以配置 diff 字段继续向下拆分，最终拆分成组件粒度，每一个组件对应一个缓存预热配置，这就是缓存预热的最小单元了。

这个配置中，就存储了该组件后续缓存预热所需要的信息（存储介质，缓存中间件，过期时间，过期策略，日志分析策略，数据就绪时间检测策略...）。

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031252295.png)

### 任务执行

Monitor Service 分析完日志后，会将分析结果封装为一个缓存预热任务，发送给对应的服务上（本质上就是一次 RPC 通信），由任务执行器来执行具体的任务，实现缓存预热。

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202412031258427.png)

### 其他问题

分布式问题：

- 我们内部都是分布式系统，那就必然存在大量的分布式问题需要解决，例如：数据一致性问题，通信问题，服务安全问题，共识问题等。

扩展性问题：

- 缓存预热服务会提供很多接口，便于业务方，在缓存预热的关键流程上进行操作，增加自己需要的业务逻辑。

数据就绪问题：

- 大数据项目有一个非常头疼的业务问题，即数据就绪问题。由于数据量非常庞大，大数据通常采用 ETL + 定时任务 的方式刷新数据，例如，每天在凌晨 3 点，开始计算昨天的数据，然后将计算结果写入到表中。在这个计算的过程中，数据是没有就绪的，即我们想要查询昨天的数据是无法查询不到的，必须要等待定时任务计算完成。这就要求我们的缓存预热任务必须在数据就绪后执行，否则会将空数据缓存起来，造成非常严重的一致性问题。


