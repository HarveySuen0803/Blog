### File Descriptor

fd（file descriptor，文件描述符）是一个整数，用于表示进程打开的文件或其他输入/输出资源的引用。它是一种抽象的标识符，用来统一管理文件、设备、套接字等资源，操作系统通过文件描述符来追踪和管理这些资源。

每个进程都有一个文件描述符表（file descriptor table），由操作系统维护。文件描述符是表中的索引值，通常是一个非负整数。文件描述符与内核中的文件对象相关联，文件对象记录了文件的具体状态，如偏移量、权限等。

open() 调用会让操作系统创建或打开文件，返回一个文件描述符 fd。

- 操作系统在内核中为 fd 分配一个文件对象，记录文件名、打开模式、当前偏移量等信息。
- 例如，返回值 fd = 3，它是该进程的文件描述符表中的一个索引。通常，0、1 和 2 分别对应标准输入、标准输出和标准错误，3 是进程打开的第一个文件。

```c
// 打开文件，获取文件描述符
int fd = open("example.txt", O_RDWR | O_CREAT, 0644);
```

write() 使用 fd 来找到文件对象，将 text 中的数据写入到文件。

系统调用流程：

- 用户态传递 fd 和数据到内核态。
- 内核根据 fd 找到对应的文件对象。
- 将数据写入文件的指定位置，并更新文件偏移量。

```c
// 写入内容到文件
const char *text = "Hello, File Descriptor!";
ssize_t bytes_written = write(fd, text, 24);
```

lseek() 会操作内核中的文件对象，将偏移量设置为指定位置。

```c
// 调整文件指针到文件开头，用于后续读取。
lseek(fd, 0, SEEK_SET);
```

read() 使用 fd 来找到文件对象，从当前偏移量读取数据。

系统调用流程类似于 write()，但方向是从文件读取到内存。

```c
ssize_t bytes_read = read(fd, buffer, 24);
```

close() 释放文件描述符在文件描述符表中的位置。

如果这是最后一个引用，内核会释放与文件对象相关的资源。

```c
close(fd);
```

### Mode

为了避免 User App 破坏 Kernel, 需要分离 User 和 Kernel, 就分为了 User Space 和 Kernel Space. User Space 只能执行 Ring3, 不能直接调用系统资源, 需要通过 Kernel 提供的 System Call Interface 访问. Kernel Space 可以执行 Ring0, 调用一切系统资源

进程运行时, 既要执行 Ring3, 也要执行 Ring0, 所以需要频繁切换 User Mode 和 Kernel Mode

User 想要读取数据, 发送请求给 System Call Interface, 等待 Kernel 查询数据 (eg: 从 Disk 或 Network 中查询数据), 找到数据后, 先存储到 Kernel Space 的 Buffer 中, 再拷贝到 User Space 的 Buffer 中, 完成一次读取操作

User 想要写入数据时, 也需要先写入到 User Space 的 Buffer 中, 再复制到 Kernel Space 的 Buffer 中, Kernel 再从 Buffer 中读取数据, 写入到 Disk, 完成一次写入操作

![](https://note-sun.oss-cn-shanghai.aliyuncs.com/image/202401031139646.png)

### 回刷机制

操作系统的回刷机制（Write-Back Mechanism），也称为写回机制，是指将内存中的脏数据（Dirty Data）同步到磁盘的过程。这一机制主要目的是在提高系统 I/O 性能的同时保证数据持久化的可靠性。通过写回机制，操作系统可以延迟数据写入磁盘的时间，将数据写入内存后立即返回，减少频繁的磁盘 I/O 操作。

#### 回刷机制中的基本概念

在了解回刷机制之前，首先需要理解以下几个关键概念：

- 脏页（Dirty Page）：指被修改但尚未写入磁盘的内存页。在写操作后，数据被存放在内存中的 Page Cache 内，标记为“脏”状态。
- Page Cache：用于缓存文件系统数据的内存区域，可以加速文件的读写操作。
- 回刷（Write-Back）：指将脏页中的数据同步到磁盘的过程，使数据得到持久化保存。
- 写直达（Write-Through）：与写回不同，写直达机制在每次写操作后立即将数据写入磁盘，不做延迟。

回刷机制延迟了磁盘写入，通过控制脏页的数量和写入频率，操作系统可以减少磁盘写入的次数，从而提升性能。

#### 回刷机制的执行流程

1. 标记脏页：当数据被写入到 Page Cache 时，页面会被标记为“脏”。
2. 检查触发条件：操作系统定期检查脏页数量、系统内存压力、以及文件状态等触发条件。
3. 触发回刷：当触发条件满足时，系统会启动后台回刷进程（如 pdflush 或 kswapd），扫描脏页列表，将数据写入磁盘。
4. 写回到磁盘：回刷进程按 FIFO（先进先出）顺序将脏页写入磁盘，每次写入一部分，以避免磁盘 I/O 阻塞。

#### 回刷机制的触发条件

##### 定期回刷

操作系统通常会以固定的时间间隔进行脏页回刷，保证数据的最终一致性。

时间间隔可以在 Linux 系统中通过 /proc/sys/vm/dirty_writeback_centisecs 配置项调整，该项的值单位为百分之一秒，默认值通常为 500（即 5 秒）。

例如，将该值设置为 1000 表示每 10 秒执行一次回刷操作，清理内存中的脏页。

##### 脏页数量达到阈值

当系统中的脏页数量达到一定的比例或绝对值时，回刷机制会被触发，清理部分脏页。

配置阈值：

- 配置 /proc/sys/vm/dirty_ratio 系统允许的最大脏页比例，默认为 20%。当脏页超过总内存的这个比例时，新的写操作会被阻塞，等待回刷完成。
- 配置 /proc/sys/vm/dirty_background_ratio 后台回刷进程的触发比例，默认为 10%。当脏页比例超过这个值时，后台进程会主动触发回刷，但不会阻塞新的写操作。

示例：

- 如果 dirty_ratio 设置为 20%，则当脏页达到 2GB 时，操作系统会强制暂停新的写入请求，直到部分脏页被回刷，降低脏页占比。
- 如果系统总内存为 10GB，dirty_background_ratio 设置为 10%，即当脏页大小超过 1GB 时，系统会自动触发后台回刷，将部分数据写入磁盘。

##### 系统内存压力增大

当系统内存不足时，内存管理模块会触发回刷操作，将脏页写回磁盘以释放内存。这种情况下，Page Cache 中的部分脏页被写入磁盘并释放为“干净页”或被直接回收，用于满足其他应用程序的内存需求。这类回刷由内存管理模块自动触发，尤其在内存紧张时，通过写回脏页避免内存耗尽。

##### 文件关闭或显式同步操作

当系统内存不足时，内存管理模块会触发回刷操作，将脏页写回磁盘以释放内存。

这种情况下，Page Cache 中的部分脏页被写入磁盘并释放为“干净页”或被直接回收，用于满足其他应用程序的内存需求。

这类回刷由内存管理模块自动触发，尤其在内存紧张时，通过写回脏页避免内存耗尽。

##### 文件关闭或显式同步操作

当文件被关闭（如 close() 系统调用）或应用程序调用了 fsync()、fdatasync()、sync() 等同步操作时，操作系统会立即将该文件的脏页写入磁盘。

Linux 系统会在关机时调用 sync 命令，确保 Page Cache 中的所有数据写入磁盘。
